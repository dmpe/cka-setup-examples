# cks-setup-examples

[Exam Examples &amp; Setup](https://gist.github.com/bakavets/05681473ca617579156de033ba40ee7a#certified-kubernetes-administrator-cka)

Some other information:
- https://docs.linuxfoundation.org/tc-docs/certification/important-instructions-cks
- Need to know 
  - https://aquasecurity.github.io/trivy/v0.49/
- https://github.com/kodekloudhub/certified-kubernetes-security-specialist-cks-course
- https://devopscube.com/cks-exam-guide-tips/
- https://www.freecodecamp.org/news/how-to-pass-the-certified-kubernetes-security-specialist-exam/#aliases

## Exam

- 10% Cluster Setup
  - NetPolicies
  - CIS benchmark
  - Ingress control
  - Verify binaries
- 15% Cluster hardening
  - RBACs
- 15% System Hardening
  - OS footprint
  - least privilage
  - AppArmor, seccomp
- 20% Minimize vulnerabilities
  - k8s secrets
  - pod-to-pod mTLS
  - OS level security
- 20% Supply chain security
  - base image footprint
  - image registry, sign and validate images
  - Scan with Trivy
- 20% Observability
  - Audit logs
  - immutability of runtimes
  - behavioral analytics/threat detection

## Minikube setup

```
./bin/calico.sh
sudo -E minikube start
```

## Setup Kubectl

```
export EDITOR=nano
echo 'source <(kubectl completion bash)' >>~/.bashrc
echo 'alias k=kubectl' >>~/.bashrc
echo 'complete -o default -F __start_kubectl k' >>~/.bashrc
```

## Setting Namespace with context

```
k config get-contexts
k config set-context minikube --namespace kube-system
```

# Cluster Setup
## Network Policies

- no imperative way, only declarative
- NS based approach

## CIS Benchmark

- Execute as job

```
kubectl apply -f https://raw.githubusercontent.com/aquasecurity/kube-bench/\
main/job-master.yaml
```

## TLS Ingress

- Create TLS cert, sign and import 

```
openssl req -nodes -new -x509 -keyout x.key -out x.crt -subj "/CN=x.tls"
kubectl create secret tls x --cert=x.crt --key=x.key
```
- adjust ingress object with `spec.tls`

```
spec:
  tls:
  - secretName: x
    hosts:
    - a.com
  rules:
    ...
```


- to test locally, find node IP, add to `/etc/hosts` file and then do `curl`

## Protect inbound K8s ports

- use firewall
- protect cloud metadata endpoints -> Network Policies
- protect GUI such as k8s dashboard with oauth2 proxy

## Verify binaries

- https://dl.k8s.io lists all hashes
- `$(cat kubectl.sha256) kubectl | sha256sum --check` for checking it


# Cluster hardening

## Kubernetes API Server

- AuthN -> AuthZ -> Admission Controller -> Validation
- AC verifies if request is well-formed or needs to be modified.
- Validation optional, can be in AC.
- API Server is exposed: 
  - kubernetes.default.svc to avoid IP for API server, e.g. from inside pod
    - its endpoint points to the IP/port
  - e.g. in pod via env variables `KUBERNETES_SERVICE_HOST` and `_PORT`
- access with client cert
- from kubeconfig extract base64 encoded values and then execute
```
curl --cacert ca --cert kubernetes-admin.crt --key kubernetes-admin.key ...
```

### Restricting Access

- do not expose public k8s API server
- limit permissions via RBAC
- add new users

  - crete private key `openssl genrsa -out johndoe.key 2048`
  - create and approve CertSignReq 
    ```
    openssl req -new -key johndoe.key -out johndoe.csr
    cat johndoe.csr | base64 | tr -d "\n"
    cat <<EOF | kubectl apply -f -
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: johndoe
spec:
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tL...
  signerName: kubernetes.io/kube-apiserver-client
  expirationSeconds: 86400
  usages:
  - client auth
EOF
  kubectl certificate approve johndoe
  kubectl get csr johndoe -o jsonpath={.status.certificate} | base64 -d > johndoe.crt
    ```
  - add Role and assign Role to RB with the user
  - add to kubeconfig
  ```
  kubectl config set-credentials johndoe --client-key=johndoe.key \
--client-certificate=johndoe.crt --embed-certs=true
  kubectl config set-context johndoe --cluster=minikube --user=johndoe
  ```

- SA -> disable automount token in the pod
- SA token can be generated by `create token` or via k8s secret with special type and annotation
- Update K8s frequently

### System Hardening

- removing packages, managing users/groups, ports, FW rules
- minimalize OS host footprint -> disable & remove not used services
- principle of least privilege
- /etc/passwd /etc/group
- adduser && `su ben` vs `su - ben`
- groupadd abc && usermod -g group username
- groupdel abc
- chown file permissions
- open ports -> netstat/ss
- Kernel Hardening with `seccomp` and `AppArmor`
- `AA`
  - access control, a sec. layer between app and system functions
  - alternative to SeLinux
  - rules can define what app can/cannot do
  - must be loaded in AA before take effect -> every worker node
  - `aa-status` - 2 modes: `enforce` and `complain`
  - load profile -> `apparmor_parser /etc/apparmor.d/k8s-deny-write` (enforce by default; or with `-C` )
  - then apply profile to container via annotation:
    - key is `container.apparmor.security.beta.kubernetes.io/<container-name>`
    - value is `localhost/<profile-name>`
- `seccomp`
  - restrict calls made from userspace into kernel
  - opt-in pod-by-pod basis; default can be choosen

```
securityContext:
  seccompProfile:
    type: RuntimeDefault
```
  - or a custom version

```
securityContext:
  seccompProfile:
    type: Localhost
    localhostProfile: profiles/mkdir-violation.json
```

- use also `sysctl`

```
securityContext:
  sysctls:
  - name: net.core.somaxconn
    value: "1024"
  - name: debug.iotrace
    value: "1"
```

### Microservice vulnerabilities

- define security settings not only on OS level, but also on container/pod level
with tools such as PSA/Open Policy Agent
- avoid root in contianer because it is a root on the host too; could escape the pod, and infect the OS system
- set `securityContext`, which defines privilege and ACLs for pod
  - user/group ID
  - grant some root priviledges
  - runAsNonRoot, priviledged, etc.
- pod security admission:
  - which security standart to follow
  - opt in to add label to a namespace
  - label: prefix, mode (warn, audit, enforce) and level (baseline, priviledged, restricted)
  - no flexibility, no customization
- open policy agent (OPA) / Gatekeeper
  - Rego language to write rules
  - gatekeeper uses OPA in k8s
  - create constraint template with Rego and constraint
- storing secrets in `etcd`
  - encrypt etcd DB via EncryptionConfiguration
  - also needs to adjust API server with that file
- container runtime sandbox: Kata and gVisor
- Kata Containers:
  - runs containers in lightweigt VM
- gVisor:
  - implements linux kernel on host -> syscalls not shared anymore
  - uses `runsc` runtime -> containerd needs adjustments
  - define and reference runtime class
  - exec pod and `dmesg` - see gVisor
- pod-to-pod mTLS
  - by default, no encryption between pods
  - mTLS allows to verify client identity
  - *alternative*: WireGuard 

### Supply Chain Security

- minimazing base image
  - avoid shell container, harder to troubleshoot
  - e.g. use alpine or distroless
- multistage approach to building images
  - separate build from runtime stage
- reduce number of layers
- secure supply chain
  - sign container images
  - use SHA256 hash digest for images
- use private container registry
- use OPA/kyverno/other policy engines
- admission controller webhook
  - e.g. ImagePolicyWebhook
  - first define `/etc/kubernetes/admission-control/image-policy-webhook-admission-config.yaml`
  - create kubeconfig which points to webhook service endpoint
  - next, adjust API server
    - `--enable-admission-plugins=...ImagePolicyWebhook...`
    - `--admission-control-config-file=...file...` + volume mounts
- static analysis of docker images -> `hadolint`
- `kubesec` for YAML analysis
- use `trivy` for docker image analysis

### Monitoring, Logging, Runtime Security

- Behaviour Analytics of VM nodes with Falco/Tetragon/Tracee
- Falco - host + container level activity
  - alert fires if matches specific event
  - must be on all workers in k8s cluster
  - `/etc/falco` for config directory
  - rules consist of rule, macro and lists
- use immutable containers
  - use distroless images
- `readOnlyRootFilesystem`: true
  - use `EmptryDir` for Write operations, e.g. Nginx
- audit logs:
  - audit policy yaml: 4 levels
  - kube api server needs to be adjusted, 2 flags
